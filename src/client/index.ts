/**
 * Implementation of the dRPC client factory for HTTP and libp2p transports.
 * Core implementation of the client functionality that's exposed through src/drpc-client.ts.
 *
 * This file handles both HTTP and libp2p transport paths and serves as the internal
 * implementation for the public API defined in src/drpc-client.ts.
 *
 * The code follows Go's NewClient[T] pattern but has been modularized for better
 * maintainability and code organization.
 */
import { Client, createClient } from "@connectrpc/connect";
import { multiaddr } from "@multiformats/multiaddr";
import { DescService } from "@bufbuild/protobuf";
import { createLibp2pTransport } from "./core/libp2p-transport";
import { createSmartHttpLibp2pTransport } from "./core/http-transport";
import { createLibp2pHost } from "./core/libp2p-host";
import { DRPCOptions } from "./core/types";
import { Libp2p } from "libp2p";
import { ServiceMap } from "@libp2p/interface";
import { discoverOptimalConnection } from "./core/peer-discovery";

// Global/shared libp2p host reference counting
interface LibP2PHostReference {
  libp2p: any;
  refCount: number;
  logger?: any;
}

let globalHostRef: LibP2PHostReference | null = null;

/**
 * Get or create the global libp2p host instance with reference counting
 */
async function getLibp2pHostInstance(options: DRPCOptions): Promise<Libp2p<ServiceMap>> {
  if (!globalHostRef) {
    let logger = options.logger.createChildLogger({
      contextName: "dRPC-Client",
    });
    logger.debug("[getLibp2pHostInstance] Creating new libp2p host instance.");
    const libp2p = await createLibp2pHost();
    globalHostRef = {
      libp2p,
      refCount: 1,
      logger,
    };
  } else {
    globalHostRef.logger.debug(
      "[getLibp2pHostInstance] Reusing existing libp2p host instance.",
    );
    globalHostRef.refCount++; // Increment ref count for each new client using this shared host
  }
  return globalHostRef.libp2p;
}

/**
 * Release a reference to the global libp2p host.
 * When reference count reaches zero, the host is stopped and cleaned up.
 */
async function releaseLibp2pHostInstance(): Promise<void> {
  if (!globalHostRef) {
    return;
  }

  globalHostRef.refCount--;

  globalHostRef.logger.debug(
    `[releaseLibp2pHostInstance] Released libp2p host instance. Remaining refs: ${globalHostRef.refCount}`,
  );

  if (globalHostRef.refCount <= 0) {
    const libp2p = globalHostRef.libp2p;
    let logger = globalHostRef.logger;
    globalHostRef = null;

    logger.debug(
      "[releaseLibp2pHostInstance] Stopping and cleaning up libp2p host instance.",
    );
    try {
      if (libp2p && typeof libp2p.stop === "function") {
        await libp2p.stop();
      }
    } catch (err) {
      logger.error("[releaseLibp2pHostInstance] Error stopping libp2p:", err);
    }
  }
}

/**
 * DRPCClient combines the standard Client capabilities with dRPC-specific methods.
 * This type extends the base Client type with an additional Close method.
 */
export type DRPCClient<TService extends DescService> = Client<TService> & {
  /**
   * Close releases any resources used by this client and should be called when
   * the client is no longer needed.
   */
  Close(): Promise<void>;
};

/**
 * NewClient creates a ConnectRPC client for HTTP or libp2p.
 *
 * @param addr - server address (http(s)://... or multiaddr)
 * @param service - Service definition generated by @connectrpc/protoc-gen-connect-es
 * @param options - Client options
 * @returns Client with direct methods for the service
 */
export async function NewClient<TService extends DescService>(
  addr: string,
  service: TService,
  options: DRPCOptions,
): Promise<DRPCClient<TService>> {
  let logger = options.logger;
  // HTTP path
  if (addr.startsWith("http://") || addr.startsWith("https://")) {
    // Get or create the global libp2p host
    const libp2p = await getLibp2pHostInstance(options);
    logger.debug(
      `[NewClient] HTTP/S address detected: ${addr}. Using SmartHttpLibp2pTransport.`,
    );

    // Create the transport and client
    const transport = await createSmartHttpLibp2pTransport(
      addr,
      libp2p,
      options,
    );
    const baseClient = createClient(service, transport) as any;

    // Add Close method to the client
    const drpcClient = baseClient as DRPCClient<TService>;
    drpcClient.Close = async () => {
      logger.debug(`[Client.Close] Closing HTTP client for ${addr}`);
      await releaseLibp2pHostInstance();
    };

    return drpcClient;
  }

  // libp2p path - use multiaddr to validate directly
  try {
    // Get or create the global libp2p host
    const libp2p = await getLibp2pHostInstance(options);

    // // Parse and validate the multiaddr
    // const ma = multiaddr(addr);
    // const peerIdStr = ma.getPeerId();
    // if (!peerIdStr) {
    //   throw new Error("Multiaddr missing peer ID");
    // }

    // // Check if this is a relay address (contains p2p-circuit)
    // const isRelay = addr.includes("/p2p-circuit/");
    // if (isRelay) {
    //   logger.debug(`[NewClient] Using relay path for ${addr}`);
    // }

    // query the peer info
    const res = await discoverOptimalConnection(libp2p, addr);
    if (res.error) {
      throw new Error(`Failed to find connection path to ${addr} err: ${res.error}`);
    }

    // Create transport and client
    const transport = createLibp2pTransport(libp2p, res.multiaddr, options);
    const baseClient = createClient(service, transport) as any;

    // Add Close method to the client
    const drpcClient = baseClient as DRPCClient<TService>;
    drpcClient.Close = async () => {
      logger.debug(`[Client.Close] Closing libp2p client for ${addr}`);
      await releaseLibp2pHostInstance();
    };

    return drpcClient;
  } catch (error) {
    logger.error(`[NewClient] Error creating libp2p client: ${error}`);
    throw new Error(`Invalid multiaddr or libp2p error: ${error}`);
  }
}
