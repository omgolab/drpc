/**
 * Generic dRPC client factory for HTTP/2 and libp2p transports.
 * 1:1 port of Go's NewClient[T] pattern.
 */

import { createClient } from "@connectrpc/connect";
import { createConnectTransport } from "@connectrpc/connect-web";
import { createClientMethodSerializers } from "@connectrpc/connect/protocol";
import { create } from "@bufbuild/protobuf";
import { Code } from "@connectrpc/connect";
import { ConnectError } from "@connectrpc/connect";
import type {
  Client,
  Transport,
  StreamResponse,
  UnaryResponse
} from "@connectrpc/connect";
import type {
  DescService,
  DescMethodUnary,
  DescMethodStreaming,
  DescMessage,
  MessageInitShape,
  MessageShape
} from "@bufbuild/protobuf";
import { multiaddr } from "@multiformats/multiaddr";
import { createLibp2pHost } from "./libp2p-host";
import type { ContextValues } from "@connectrpc/connect";

// Configuration
const PROTOCOL_ID = "/connect-envelope/1.0.0"; // Updated protocol for Connect envelope
const DEBUG = true; // For development; set to false in production
const END_STREAM_FLAG = 1; // Flag byte value for end-stream messages
const METADATA_FLAG = 2; // Flag byte for metadata envelope

// Early Export to avoid bundling issues
export { NewClient };

/**
 * NewClient creates a ConnectRPC client for HTTP/2 or libp2p.
 * @param addr - server address (http(s)://... or multiaddr)
 * @param service - Service definition generated by @connectrpc/protoc-gen-connect-es
 * @returns Client with direct methods for the service
 */
async function NewClient<TService extends DescService>(
  addr: string,
  service: TService,
  options?: { logger?: any; exposeLibp2p?: boolean },
): Promise<Client<TService> & { __libp2p?: any }> {
  // HTTP/2 path
  if (addr.startsWith("http://") || addr.startsWith("https://")) {
    const transport = createConnectTransport({ baseUrl: addr });
    return createClient(service, transport) as any;
  }

  // libp2p path - use multiaddr to validate
  try {
    // Create libp2p host in client mode
    const { libp2p } = await createLibp2pHost({
      isClientMode: true,
      logger: options?.logger,
    });

    const ma = multiaddr(addr);
    const peerIdStr = ma.getPeerId();
    if (!peerIdStr) throw new Error("Multiaddr missing peer ID");

    // Check if this is a relay address (contains p2p-circuit)
    const isRelay = addr.includes('/p2p-circuit/');
    if (isRelay && DEBUG) {
      console.debug(`[NewClient] Using relay path for ${addr}`);
    }

    // Create transport and client
    const transport = createLibp2pTransport(libp2p, ma);
    const client = createClient(service, transport) as any;

    // Optionally expose libp2p instance
    if (options?.exposeLibp2p) {
      client.__libp2p = libp2p;
    }

    return client;
  } catch (error) {
    console.error(`[NewClient] Error creating libp2p client: ${error}`);
    throw new Error(`Invalid multiaddr or libp2p error: ${error}`);
  }
}

/**
 * Extract the target multiaddr for dialing, handling relay format if present
 */
function extractDialTargetFromMultiaddr(ma: any): any {
  const isRelay = ma.toString().includes('/p2p-circuit/');
  if (!isRelay) {
    return ma;
  }

  // For relay addresses, extract the direct portion for our tests
  // In a production relay setup, the full relay address would be used
  const fullAddrStr = ma.toString();
  const parts = fullAddrStr.split('/p2p-circuit/');

  if (parts.length >= 2) {
    const directAddrPart = parts[0];
    if (directAddrPart) {
      try {
        return multiaddr(directAddrPart);
      } catch (e) {
        console.warn(`[libp2pTransport] Error parsing direct part from relay:`, e);
      }
    }
  }

  // Fallback to original address
  return ma;
}

/**
 * Concatenate multiple Uint8Arrays
 */
function concatUint8Arrays(arrays: Uint8Array[]): Uint8Array {
  const totalLength = arrays.reduce((len, arr) => len + arr.length, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const arr of arrays) {
    result.set(arr, offset);
    offset += arr.length;
  }
  return result;
}

/**
 * Creates a Connect protocol envelope with a flag byte and length prefix.
 * Format: [flag(1)][length(4)][data(N)]
 */
function createConnectEnvelope(messageBytes: Uint8Array, flagByte: number = 0): Uint8Array {
  const envelope = new Uint8Array(5 + messageBytes.length);

  // Flag byte (0 for regular message, 1 for end stream)
  envelope[0] = flagByte;

  // Message length (4 bytes, big-endian)
  const len = messageBytes.length;
  envelope[1] = (len >>> 24) & 0xFF;
  envelope[2] = (len >>> 16) & 0xFF;
  envelope[3] = (len >>> 8) & 0xFF;
  envelope[4] = len & 0xFF;

  // Message data
  envelope.set(messageBytes, 5);

  return envelope;
}

/**
 * Libp2p transport implementation for Connect RPC with compatibility
 * for the Connect protocol format.
 */
function createLibp2pTransport(libp2p: any, ma: any): Transport {
  return {
    async unary<I extends DescMessage, O extends DescMessage>(
      method: DescMethodUnary<I, O>,
      signal: AbortSignal | undefined,
      timeoutMs: number | undefined,
      header: HeadersInit | undefined,
      input: MessageInitShape<I>,
      contextValues?: ContextValues,
    ): Promise<UnaryResponse<I, O>> {
      if (DEBUG) console.debug(`[libp2pTransport] Unary call: ${method.name}`);
      try {
        const { serialize, parse } = createClientMethodSerializers(method, true);
        const inputMessage = create(method.input, input);
        const messageBytes = serialize(inputMessage);

        // First envelope: metadata (flag=2, JSON with method path)
        const metadataEnvelope = createMetadataEnvelope(method);
        // Second envelope: request (flag=0, protobuf)
        const requestEnvelope = createConnectEnvelope(messageBytes);

        let targetMa = extractDialTargetFromMultiaddr(ma);
        console.log(`[libp2pTransport] Target multiaddr: ${targetMa.toString()}`);

        if (DEBUG) console.debug(`[libp2pTransport] Dialing ${targetMa.toString()} with protocol ${PROTOCOL_ID}`);
        const stream = await libp2p.dialProtocol(targetMa, PROTOCOL_ID);
        console.log(`[libp2pTransport] Successfully established stream to ${targetMa.toString()}`);

        try {
          let aborted = false;
          if (signal) {
            if (signal.aborted) throw new Error("Request aborted");
            signal.addEventListener('abort', () => {
              aborted = true;
              stream.close().catch(() => { });
            });
          }

          if (DEBUG) console.debug(`[libp2pTransport] Sending metadata envelope (${metadataEnvelope.byteLength} bytes)`);
          await stream.sink([metadataEnvelope]);
          if (DEBUG) console.debug(`[libp2pTransport] Sending unary request envelope (${requestEnvelope.byteLength} bytes)`);
          await stream.sink([requestEnvelope]);
          await stream.closeWrite();

          const chunks: Uint8Array[] = [];
          for await (const chunk of stream.source) {
            if (aborted) break;
            chunks.push(chunk);
          }

          const responseData = chunks.length === 1 ? chunks[0] : concatUint8Arrays(chunks);

          // Parse response envelope(s)
          let offset = 0;
          let responseMessage: MessageShape<O> | undefined;
          while (offset + 5 <= responseData.length) {
            const flagByte = responseData[offset];
            const messageLength =
              (responseData[offset + 1] << 24) |
              (responseData[offset + 2] << 16) |
              (responseData[offset + 3] << 8) |
              responseData[offset + 4];
            if (offset + 5 + messageLength > responseData.length) break;
            const messageBytes = responseData.subarray(offset + 5, offset + 5 + messageLength);
            if (flagByte === 0) {
              try {
                responseMessage = parse(messageBytes);
              } catch (err) {
                console.warn(`[libp2pTransport] Error parsing response:`, err);
              }
            } else if (flagByte === END_STREAM_FLAG) {
              if (DEBUG) console.debug(`[libp2pTransport] Received end-of-stream envelope`);
              break;
            } else {
              if (DEBUG) console.debug(`[libp2pTransport] Skipping envelope with flag ${flagByte}`);
            }
            offset += 5 + messageLength;
          }

          if (!responseMessage) {
            throw new ConnectError("No response message received", Code.Internal);
          }

          return {
            stream: false,
            message: responseMessage,
            header: new Headers(),
            trailer: new Headers(),
            method,
            service: method.parent
          };
        } finally {
          if (DEBUG) console.debug(`[libp2pTransport] Closing unary stream`);
          stream.close().catch(() => { });
        }
      } catch (error: any) {
        console.error(`[libp2pTransport] Unary call error: ${error.message || error}`);
        if (error.stack) console.error(error.stack);
        throw error;
      }
    },

    async stream<I extends DescMessage, O extends DescMessage>(
      method: DescMethodStreaming<I, O>,
      signal: AbortSignal | undefined,
      timeoutMs: number | undefined,
      header: HeadersInit | undefined,
      input: AsyncIterable<MessageInitShape<I>>,
      contextValues?: ContextValues,
    ): Promise<StreamResponse<I, O>> {
      if (DEBUG) console.debug(`[libp2pTransport] Stream call: ${method.name}`);
      try {
        const { serialize, parse } = createClientMethodSerializers(method, true);

        let targetMa = extractDialTargetFromMultiaddr(ma);
        console.log(`[libp2pTransport] Target multiaddr for streaming: ${targetMa.toString()}`);

        if (DEBUG) console.debug(`[libp2pTransport] Dialing ${targetMa.toString()} with protocol ${PROTOCOL_ID}`);
        const stream = await libp2p.dialProtocol(targetMa, PROTOCOL_ID);
        console.log(`[libp2pTransport] Successfully established stream connection to ${targetMa.toString()}`);

        let aborted = false;
        if (signal) {
          if (signal.aborted) {
            stream.close().catch(() => { });
            throw new Error("Request aborted");
          }
          signal.addEventListener('abort', () => {
            aborted = true;
            stream.close().catch(() => { });
          });
        }

        // First envelope: metadata
        const metadataEnvelope = createMetadataEnvelope(method);
        if (DEBUG) console.debug(`[libp2pTransport] Sending metadata envelope (${metadataEnvelope.byteLength} bytes)`);
        await stream.sink([metadataEnvelope]);

        // Then send request envelopes
        const inputPromise = (async () => {
          try {
            for await (const messageInit of input) {
              if (aborted) break;
              const messageData = serialize(create(method.input, messageInit));
              const envelopeBytes = createConnectEnvelope(messageData);
              if (DEBUG) console.debug(`[libp2pTransport] Sending stream envelope (${envelopeBytes.length} bytes)`);
              await stream.sink([envelopeBytes]);
            }
            if (!aborted) {
              if (DEBUG) console.debug(`[libp2pTransport] Sending end-of-stream marker`);
              const endEnvelope = createConnectEnvelope(new Uint8Array(0), END_STREAM_FLAG);
              await stream.sink([endEnvelope]);
              await stream.closeWrite();
            }
          } catch (err) {
            console.error(`[libp2pTransport] Error sending stream data:`, err);
            stream.close().catch(() => { });
          }
        })();

        const responseMessages = (async function* () {
          try {
            const buffers: Uint8Array[] = [];
            for await (const chunk of stream.source) {
              if (aborted) break;
              buffers.push(chunk);
            }
            const combined = concatUint8Arrays(buffers);
            let offset = 0;
            while (offset + 5 <= combined.length) {
              const flagByte = combined[offset];
              const messageLength =
                (combined[offset + 1] << 24) |
                (combined[offset + 2] << 16) |
                (combined[offset + 3] << 8) |
                combined[offset + 4];
              if (offset + 5 + messageLength > combined.length) break;
              const messageData = combined.subarray(offset + 5, offset + 5 + messageLength);
              if (flagByte === END_STREAM_FLAG) {
                if (DEBUG) console.debug(`[libp2pTransport] Received end-of-stream message`);
                break;
              } else if (flagByte === 0) {
                try {
                  const message = parse(messageData);
                  yield message;
                } catch (err) {
                  console.warn(`[libp2pTransport] Error parsing stream message:`, err);
                }
              } else if (flagByte === METADATA_FLAG) {
                if (DEBUG) console.debug(`[libp2pTransport] Skipping metadata envelope in response`);
              } else {
                console.warn(`[libp2pTransport] Unknown flag byte: ${flagByte}`);
              }
              offset += 5 + messageLength;
            }
          } catch (err) {
            console.error(`[libp2pTransport] Error in response stream:`, err);
            throw new ConnectError(
              `Stream error: ${err}`,
              Code.Internal
            );
          } finally {
            await inputPromise;
            if (DEBUG) console.debug(`[libp2pTransport] Closing stream`);
            stream.close().catch(() => { });
          }
        })();

        return {
          stream: true,
          message: responseMessages,
          header: new Headers({ 'content-type': 'application/connect+proto' }),
          trailer: new Headers(),
          method,
          service: method.parent
        };
      } catch (error: any) {
        console.error(`[libp2pTransport] Stream call error: ${error.message || error}`);
        if (error.stack) console.error(error.stack);
        throw error;
      }
    }
  };
}

/**
 * Creates a metadata envelope for Connect RPC, containing the method path.
 * Format: [flag(1)][length(4)][data(N)]
 */
function createMetadataEnvelope(method: { parent: { typeName: string }, name: string }): Uint8Array {
  // Connect expects path as "/<service>/<method>"
  const path = `/${method.parent.typeName}/${method.name}`;
  const meta = { path };
  const json = JSON.stringify(meta);
  const bytes = new TextEncoder().encode(json);
  return createConnectEnvelope(bytes, METADATA_FLAG);
}
