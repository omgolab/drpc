This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: examples/multipro/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
examples/
  multipro/
    pb/
      p2p.pb.go
      p2p.proto
    .gitignore
    AUTHORS
    echo.go
    LICENSE
    main_test.go
    main.go
    node.go
    ping.go
    README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="examples/multipro/pb/p2p.pb.go">
// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: p2p.proto
⋮----
package protocols_p2p
⋮----
import (
	fmt "fmt"

	proto "github.com/gogo/protobuf/proto"

	math "math"
)
⋮----
fmt "fmt"
⋮----
proto "github.com/gogo/protobuf/proto"
⋮----
math "math"
⋮----
// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
⋮----
// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package
⋮----
// designed to be shared between all app protocols
type MessageData struct {
	// shared between all requests
	ClientVersion        string   `protobuf:"bytes,1,opt,name=clientVersion,proto3" json:"clientVersion,omitempty"`
	Timestamp            int64    `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Id                   string   `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	Gossip               bool     `protobuf:"varint,4,opt,name=gossip,proto3" json:"gossip,omitempty"`
	NodeId               string   `protobuf:"bytes,5,opt,name=nodeId,proto3" json:"nodeId,omitempty"`
	NodePubKey           []byte   `protobuf:"bytes,6,opt,name=nodePubKey,proto3" json:"nodePubKey,omitempty"`
	Sign                 []byte   `protobuf:"bytes,7,opt,name=sign,proto3" json:"sign,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
⋮----
// shared between all requests
⋮----
func (m *MessageData) Reset()
func (m *MessageData) String() string
func (*MessageData) ProtoMessage()
func (*MessageData) Descriptor() ([]byte, []int)
func (m *MessageData) XXX_Unmarshal(b []byte) error
func (m *MessageData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error)
func (dst *MessageData) XXX_Merge(src proto.Message)
func (m *MessageData) XXX_Size() int
func (m *MessageData) XXX_DiscardUnknown()
⋮----
var xxx_messageInfo_MessageData proto.InternalMessageInfo
⋮----
func (m *MessageData) GetClientVersion() string
⋮----
func (m *MessageData) GetTimestamp() int64
⋮----
func (m *MessageData) GetId() string
⋮----
func (m *MessageData) GetGossip() bool
⋮----
func (m *MessageData) GetNodeId() string
⋮----
func (m *MessageData) GetNodePubKey() []byte
⋮----
func (m *MessageData) GetSign() []byte
⋮----
// A protocol defines a set of requests and responses.
type PingRequest struct {
	MessageData *MessageData `protobuf:"bytes,1,opt,name=messageData" json:"messageData,omitempty"`
	// method specific data
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
⋮----
// method specific data
⋮----
var xxx_messageInfo_PingRequest proto.InternalMessageInfo
⋮----
func (m *PingRequest) GetMessageData() *MessageData
⋮----
func (m *PingRequest) GetMessage() string
⋮----
type PingResponse struct {
	MessageData *MessageData `protobuf:"bytes,1,opt,name=messageData" json:"messageData,omitempty"`
	// response specific data
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
⋮----
// response specific data
⋮----
var xxx_messageInfo_PingResponse proto.InternalMessageInfo
⋮----
// A protocol defines a set of requests and responses
type EchoRequest struct {
	MessageData *MessageData `protobuf:"bytes,1,opt,name=messageData" json:"messageData,omitempty"`
	// method specific data
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
⋮----
var xxx_messageInfo_EchoRequest proto.InternalMessageInfo
⋮----
type EchoResponse struct {
	MessageData *MessageData `protobuf:"bytes,1,opt,name=messageData" json:"messageData,omitempty"`
	// response specific data
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
⋮----
var xxx_messageInfo_EchoResponse proto.InternalMessageInfo
⋮----
func init()
⋮----
var fileDescriptor_p2p_c8fd4e6dd1b6d221 = []byte{
	// 261 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x8f, 0xb1, 0x4e, 0xc3, 0x30,
	0x10, 0x86, 0xe5, 0xb6, 0xa4, 0xe4, 0xdc, 0x32, 0xdc, 0x80, 0x2c, 0x84, 0x50, 0x14, 0x31, 0x64,
	0xca, 0x10, 0x56, 0x46, 0x18, 0x10, 0x42, 0xaa, 0x3c, 0xb0, 0xa7, 0xc9, 0x11, 0x2c, 0x35, 0xb6,
	0xe9, 0xb9, 0x03, 0x0f, 0xc8, 0x7b, 0xa1, 0xba, 0x41, 0x4d, 0x1f, 0xa0, 0x4c, 0xbe, 0xff, 0xf3,
	0xd9, 0xbf, 0x3e, 0x48, 0x7d, 0xe5, 0x4b, 0xbf, 0x75, 0xc1, 0xe1, 0x32, 0x1e, 0x8d, 0xdb, 0x70,
	0xe9, 0x2b, 0x9f, 0xff, 0x08, 0x90, 0x6f, 0xc4, 0x5c, 0x77, 0xf4, 0x54, 0x87, 0x1a, 0xef, 0x61,
	0xd9, 0x6c, 0x0c, 0xd9, 0xf0, 0x4e, 0x5b, 0x36, 0xce, 0x2a, 0x91, 0x89, 0x22, 0xd5, 0xa7, 0x10,
	0x6f, 0x21, 0x0d, 0xa6, 0x27, 0x0e, 0x75, 0xef, 0xd5, 0x24, 0x13, 0xc5, 0x54, 0x1f, 0x01, 0x5e,
	0xc1, 0xc4, 0xb4, 0x6a, 0x1a, 0x1f, 0x4e, 0x4c, 0x8b, 0xd7, 0x90, 0x74, 0x8e, 0xd9, 0x78, 0x35,
	0xcb, 0x44, 0x71, 0xa9, 0x87, 0xb4, 0xe7, 0xd6, 0xb5, 0xf4, 0xd2, 0xaa, 0x8b, 0xb8, 0x3b, 0x24,
	0xbc, 0x03, 0xd8, 0x4f, 0xab, 0xdd, 0xfa, 0x95, 0xbe, 0x55, 0x92, 0x89, 0x62, 0xa1, 0x47, 0x04,
	0x11, 0x66, 0x6c, 0x3a, 0xab, 0xe6, 0xf1, 0x26, 0xce, 0x39, 0x81, 0x5c, 0x19, 0xdb, 0x69, 0xfa,
	0xda, 0x11, 0x07, 0x7c, 0x04, 0xd9, 0x1f, 0xad, 0xa2, 0x84, 0xac, 0x6e, 0xca, 0x13, 0xf7, 0x72,
	0xe4, 0xad, 0xc7, 0xeb, 0xa8, 0x60, 0x3e, 0xc4, 0x28, 0x97, 0xea, 0xbf, 0x98, 0x7f, 0xc0, 0xe2,
	0x50, 0xc3, 0xde, 0x59, 0xa6, 0xb3, 0xf5, 0x10, 0xc8, 0xe7, 0xe6, 0xd3, 0xfd, 0x83, 0xce, 0xa1,
	0xe6, 0xbc, 0x3a, 0xeb, 0x24, 0xfe, 0xf0, 0xf0, 0x1b, 0x00, 0x00, 0xff, 0xff, 0xf4, 0x47, 0x02,
	0x5e, 0x88, 0x02, 0x00, 0x00,
}
⋮----
// 261 bytes of a gzipped FileDescriptorProto
</file>

<file path="examples/multipro/pb/p2p.proto">
syntax = "proto3";

package protocols.p2p;

// designed to be shared between all app protocols
message MessageData {
    // shared between all requests
    string clientVersion = 1; // client version
    int64 timestamp = 2;     // unix time
    string id = 3;           // allows requesters to use request data when processing a response
    bool gossip = 4;         // true to have receiver peer gossip the message to neighbors
    string nodeId = 5;       // id of node that created the message (not the peer that may have sent it). =base58(multihash(nodePubKey))
    bytes nodePubKey = 6;    // Authoring node Secp256k1 public key (32bytes) - protobufs serielized
    bytes sign = 7;         // signature of message data + method specific data by message authoring node.
}

//// ping protocol

// A protocol defines a set of requests and responses.
message PingRequest {
    MessageData messageData = 1;

    // method specific data
    string message = 2;
    // add any data here....
}

message PingResponse {
    MessageData messageData = 1;

    // response specific data
    string message = 2;

    // ... add any additional message data here
}

//// echo protocol

// A protocol defines a set of requests and responses.
message EchoRequest {
    MessageData messageData = 1;

    // method specific data
    string message = 2;

    // add any additional message data here....
}

message EchoResponse {
    MessageData messageData = 1;

    // response specific data
    string message = 2;

    // ... add any additional message data here....
}
</file>

<file path="examples/multipro/.gitignore">
multipro
</file>

<file path="examples/multipro/AUTHORS">
# This is the official list of authors for copyright purposes.

Aviv Eyal <aviveyal07@gmail.com>
</file>

<file path="examples/multipro/echo.go">
package main
⋮----
import (
	"fmt"
	"io"
	"log"

	"github.com/libp2p/go-libp2p/core/host"
	"github.com/libp2p/go-libp2p/core/network"

	"github.com/gogo/protobuf/proto"
	"github.com/google/uuid"
	pb "github.com/libp2p/go-libp2p/examples/multipro/pb"
)
⋮----
"fmt"
"io"
"log"
⋮----
"github.com/libp2p/go-libp2p/core/host"
"github.com/libp2p/go-libp2p/core/network"
⋮----
"github.com/gogo/protobuf/proto"
"github.com/google/uuid"
pb "github.com/libp2p/go-libp2p/examples/multipro/pb"
⋮----
// pattern: /protocol-name/request-or-response-message/version
const echoRequest = "/echo/echoreq/0.0.1"
const echoResponse = "/echo/echoresp/0.0.1"
⋮----
type EchoProtocol struct {
	node     *Node                      // local host
	requests map[string]*pb.EchoRequest // used to access request data from response handlers
	done     chan bool                  // only for demo purposes to hold main from terminating
}
⋮----
node     *Node                      // local host
requests map[string]*pb.EchoRequest // used to access request data from response handlers
done     chan bool                  // only for demo purposes to hold main from terminating
⋮----
func NewEchoProtocol(node *Node, done chan bool) *EchoProtocol
⋮----
// design note: to implement fire-and-forget style messages you may just skip specifying a response callback.
// a fire-and-forget message will just include a request and not specify a response object
⋮----
// remote peer requests handler
func (e *EchoProtocol) onEchoRequest(s network.Stream)
⋮----
// get request data
⋮----
// unmarshal it
⋮----
// send response to the request using the message string he provided
⋮----
// sign the data
⋮----
// add the signature to the message
⋮----
// remote echo response handler
func (e *EchoProtocol) onEchoResponse(s network.Stream)
⋮----
// authenticate message content
⋮----
// locate request data and remove it if found
⋮----
// remove request from map as we have processed it here
⋮----
func (e *EchoProtocol) Echo(host host.Host) bool
⋮----
// create message data
⋮----
// store request so response handler has access to it
</file>

<file path="examples/multipro/LICENSE">
The MIT License (MIT)

Copyright (c) 2017 Aviv Eyal

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
</file>

<file path="examples/multipro/main_test.go">
package main
⋮----
import (
	"fmt"
	"log"
	"testing"

	"github.com/libp2p/go-libp2p/examples/testutils"
)
⋮----
"fmt"
"log"
"testing"
⋮----
"github.com/libp2p/go-libp2p/examples/testutils"
⋮----
func TestMain(t *testing.T)
⋮----
var h testutils.LogHarness
⋮----
// Sequence of log messages when h1 pings h2
⋮----
// Sequence of log messages when h2 pings h1
⋮----
// Sequence of log messages when h1 sends echo to h2
</file>

<file path="examples/multipro/main.go">
package main
⋮----
import (
	"fmt"
	"log"
	"math/rand"

	"github.com/libp2p/go-libp2p"
	"github.com/libp2p/go-libp2p/core/crypto"
	"github.com/libp2p/go-libp2p/core/peerstore"

	ma "github.com/multiformats/go-multiaddr"
)
⋮----
"fmt"
"log"
"math/rand"
⋮----
"github.com/libp2p/go-libp2p"
"github.com/libp2p/go-libp2p/core/crypto"
"github.com/libp2p/go-libp2p/core/peerstore"
⋮----
ma "github.com/multiformats/go-multiaddr"
⋮----
func main()
⋮----
// Choose random ports between 10000-10100
⋮----
// Make 2 hosts
⋮----
// helper method - create a lib-p2p host to listen on a port
func makeRandomNode(port int, done chan bool) *Node
⋮----
// Ignoring most errors for brevity
// See echo example for more details and better implementation
⋮----
func run(h1, h2 *Node, done <-chan bool)
⋮----
// connect peers
⋮----
// send messages using the protocols
⋮----
// block until all responses have been processed
</file>

<file path="examples/multipro/node.go">
package main
⋮----
import (
	"context"
	"log"
	"time"

	"github.com/libp2p/go-libp2p/core/crypto"
	"github.com/libp2p/go-libp2p/core/host"
	"github.com/libp2p/go-libp2p/core/peer"
	"github.com/libp2p/go-libp2p/core/protocol"
	p2p "github.com/libp2p/go-libp2p/examples/multipro/pb"

	ggio "github.com/gogo/protobuf/io"
	"github.com/gogo/protobuf/proto"
)
⋮----
"context"
"log"
"time"
⋮----
"github.com/libp2p/go-libp2p/core/crypto"
"github.com/libp2p/go-libp2p/core/host"
"github.com/libp2p/go-libp2p/core/peer"
"github.com/libp2p/go-libp2p/core/protocol"
p2p "github.com/libp2p/go-libp2p/examples/multipro/pb"
⋮----
ggio "github.com/gogo/protobuf/io"
"github.com/gogo/protobuf/proto"
⋮----
// node client version
const clientVersion = "go-p2p-node/0.0.1"
⋮----
// Node type - a p2p host implementing one or more p2p protocols
type Node struct {
	host.Host     // lib-p2p host
	*PingProtocol // ping protocol impl
	*EchoProtocol // echo protocol impl
	// add other protocols here...
}
⋮----
host.Host     // lib-p2p host
*PingProtocol // ping protocol impl
*EchoProtocol // echo protocol impl
// add other protocols here...
⋮----
// Create a new node with its implemented protocols
func NewNode(host host.Host, done chan bool) *Node
⋮----
// Authenticate incoming p2p message
// message: a protobuf go data object
// data: common p2p message data
func (n *Node) authenticateMessage(message proto.Message, data *p2p.MessageData) bool
⋮----
// store a temp ref to signature and remove it from message data
// sign is a string to allow easy reset to zero-value (empty string)
⋮----
// marshall data without the signature to protobufs3 binary format
⋮----
// restore sig in message data (for possible future use)
⋮----
// restore peer id binary format from base58 encoded node id data
⋮----
// verify the data was authored by the signing peer identified by the public key
// and signature included in the message
⋮----
// sign an outgoing p2p message payload
func (n *Node) signProtoMessage(message proto.Message) ([]byte, error)
⋮----
// sign binary data using the local node's private key
func (n *Node) signData(data []byte) ([]byte, error)
⋮----
// Verify incoming p2p message data integrity
// data: data to verify
// signature: author signature provided in the message payload
// peerId: author peer id from the message payload
// pubKeyData: author public key from the message payload
func (n *Node) verifyData(data []byte, signature []byte, peerId peer.ID, pubKeyData []byte) bool
⋮----
// extract node id from the provided public key
⋮----
// verify that message author node id matches the provided node public key
⋮----
// helper method - generate message data shared between all node's p2p protocols
// messageId: unique for requests, copied from request for responses
func (n *Node) NewMessageData(messageId string, gossip bool) *p2p.MessageData
⋮----
// Add protobuf bin data for message author public key
// this is useful for authenticating  messages forwarded by a node authored by another node
⋮----
// helper method - writes a protobuf go data object to a network stream
// data: reference of protobuf go data object to send (not the object itself)
// s: network stream to write the data to
func (n *Node) sendProtoMessage(id peer.ID, p protocol.ID, data proto.Message) bool
</file>

<file path="examples/multipro/ping.go">
package main
⋮----
import (
	"fmt"
	"io"
	"log"
	"sync"

	"github.com/libp2p/go-libp2p/core/host"
	"github.com/libp2p/go-libp2p/core/network"

	proto "github.com/gogo/protobuf/proto"
	uuid "github.com/google/uuid"
	p2p "github.com/libp2p/go-libp2p/examples/multipro/pb"
)
⋮----
"fmt"
"io"
"log"
"sync"
⋮----
"github.com/libp2p/go-libp2p/core/host"
"github.com/libp2p/go-libp2p/core/network"
⋮----
proto "github.com/gogo/protobuf/proto"
uuid "github.com/google/uuid"
p2p "github.com/libp2p/go-libp2p/examples/multipro/pb"
⋮----
// pattern: /protocol-name/request-or-response-message/version
const pingRequest = "/ping/pingreq/0.0.1"
const pingResponse = "/ping/pingresp/0.0.1"
⋮----
// PingProtocol type
type PingProtocol struct {
	node     *Node // local host
	mu       sync.Mutex
	requests map[string]*p2p.PingRequest // used to access request data from response handlers. Protected by mu
	done     chan bool                   // only for demo purposes to stop main from terminating
}
⋮----
node     *Node // local host
⋮----
requests map[string]*p2p.PingRequest // used to access request data from response handlers. Protected by mu
done     chan bool                   // only for demo purposes to stop main from terminating
⋮----
func NewPingProtocol(node *Node, done chan bool) *PingProtocol
⋮----
// remote peer requests handler
func (p *PingProtocol) onPingRequest(s network.Stream)
⋮----
// get request data
⋮----
// unmarshal it
⋮----
// generate response message
⋮----
// sign the data
⋮----
// add the signature to the message
⋮----
// send the response
⋮----
// remote ping response handler
func (p *PingProtocol) onPingResponse(s network.Stream)
⋮----
// locate request data and remove it if found
⋮----
// remove request from map as we have processed it here
⋮----
func (p *PingProtocol) Ping(host host.Host) bool
⋮----
// create message data
⋮----
// store ref request so response handler has access to it
</file>

<file path="examples/multipro/README.md">
# Protocol Multiplexing using rpc-style protobufs with libp2p

This example shows how to use protobufs to encode and transmit information between libp2p hosts using libp2p Streams.
This example expects that you are already familiar with the [echo example](https://github.com/libp2p/go-libp2p/tree/master/examples/echo).

## Build

From the `go-libp2p/examples` directory run the following:

```sh
> cd multipro/
> go build
```

## Usage

```sh
> ./multipro
```

## Details

The example creates two libp2p Hosts supporting 2 protocols: ping and echo.

Each protocol consists of RPC-style requests and responses and each request and response is a typed protobufs message (and a go data object).

This is a different pattern than defining a whole p2p protocol as one protobuf message with lots of optional fields (as can be observed in various p2p-lib protocols using protobufs such as dht).

The example shows how to match async received responses with their requests. This is useful when processing a response requires access to the request data.

The idea is to use libp2p protocol multiplexing on a per-message basis.

### Features
1. 2 fully implemented protocols using an RPC-like request-response pattern - Ping and Echo
2. Scaffolding for quickly implementing new app-level versioned RPC-like protocols
3. Full authentication of incoming message data by author (who might not be the message's sender peer)
4. Base p2p format in protobufs with fields shared by all protocol messages
5. Full access to request data when processing a response.

## Author
@avive
</file>

</files>
