This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: examples/chat-with-mdns/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
examples/
  chat-with-mdns/
    .gitignore
    flags.go
    main.go
    mdns.go
    README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="examples/chat-with-mdns/.gitignore">
chat-with-mdns
</file>

<file path="examples/chat-with-mdns/flags.go">
package main
⋮----
import (
	"flag"
)
⋮----
"flag"
⋮----
type config struct {
	RendezvousString string
	ProtocolID       string
	listenHost       string
	listenPort       int
}
⋮----
func parseFlags() *config
</file>

<file path="examples/chat-with-mdns/main.go">
package main
⋮----
import (
	"bufio"
	"context"
	"crypto/rand"
	"flag"
	"fmt"
	"os"

	"github.com/libp2p/go-libp2p"
	"github.com/libp2p/go-libp2p/core/crypto"
	"github.com/libp2p/go-libp2p/core/network"
	"github.com/libp2p/go-libp2p/core/protocol"

	"github.com/multiformats/go-multiaddr"
)
⋮----
"bufio"
"context"
"crypto/rand"
"flag"
"fmt"
"os"
⋮----
"github.com/libp2p/go-libp2p"
"github.com/libp2p/go-libp2p/core/crypto"
"github.com/libp2p/go-libp2p/core/network"
"github.com/libp2p/go-libp2p/core/protocol"
⋮----
"github.com/multiformats/go-multiaddr"
⋮----
func handleStream(stream network.Stream)
⋮----
// Create a buffer stream for non-blocking read and write.
⋮----
// 'stream' will stay open until you close it (or the other side closes it).
⋮----
func readData(rw *bufio.ReadWriter)
⋮----
// Green console colour: 	\x1b[32m
// Reset console colour: 	\x1b[0m
⋮----
func writeData(rw *bufio.ReadWriter)
⋮----
func main()
⋮----
// Creates a new RSA key pair for this host.
⋮----
// 0.0.0.0 will listen on any interface device.
⋮----
// libp2p.New constructs a new libp2p Host.
// Other options can be added here.
⋮----
// Set a function as stream handler.
// This function is called when a peer initiates a connection and starts a stream with this peer.
⋮----
for { // allows multiple peers to join
peer := <-peerChan // will block until we discover a peer
⋮----
// if other end peer id greater than us, don't connect to it, just wait for it to connect us
⋮----
// open a stream, this stream will be handled by handleStream other end
</file>

<file path="examples/chat-with-mdns/mdns.go">
package main
⋮----
import (
	"github.com/libp2p/go-libp2p/core/host"
	"github.com/libp2p/go-libp2p/core/peer"

	"github.com/libp2p/go-libp2p/p2p/discovery/mdns"
)
⋮----
"github.com/libp2p/go-libp2p/core/host"
"github.com/libp2p/go-libp2p/core/peer"
⋮----
"github.com/libp2p/go-libp2p/p2p/discovery/mdns"
⋮----
type discoveryNotifee struct {
	PeerChan chan peer.AddrInfo
}
⋮----
// interface to be called when new  peer is found
func (n *discoveryNotifee) HandlePeerFound(pi peer.AddrInfo)
⋮----
// Initialize the MDNS service
func initMDNS(peerhost host.Host, rendezvous string) chan peer.AddrInfo
⋮----
// register with service so that we get notified about peer discovery
⋮----
// An hour might be a long long period in practical applications. But this is fine for us
</file>

<file path="examples/chat-with-mdns/README.md">
# p2p chat app with libp2p [support peer discovery using mdns]

This program demonstrates a simple p2p chat application. You will learn how to discover a peer in the network (using mdns), connect to it and open a chat stream. This example is heavily influenced by (and shamelessly copied from) `chat-with-rendezvous` example

## How to build this example?

```
go get -v -d ./...

go build
```

## Usage

Use two different terminal windows to run

```
./chat-with-mdns -port 6666
./chat-with-mdns -port 6668
```


## So how does it work?

1. **Configure a p2p host**
```go
ctx := context.Background()

// libp2p.New constructs a new libp2p Host.
// Other options can be added here.
host, err := libp2p.New()
```
[libp2p.New](https://godoc.org/github.com/libp2p/go-libp2p#New) is the constructor for libp2p node. It creates a host with given configuration.

2. **Set a default handler function for incoming connections.**

This function is called on the local peer when a remote peer initiate a connection and starts a stream with the local peer.
```go
// Set a function as stream handler.
host.SetStreamHandler("/chat/1.1.0", handleStream)
```

```handleStream``` is executed for each new stream incoming to the local peer. ```stream``` is used to exchange data between local and remote peer. This example uses non blocking functions for reading and writing from this stream.

```go
func handleStream(stream net.Stream) {

    // Create a buffer stream for non blocking read and write.
    rw := bufio.NewReadWriter(bufio.NewReader(stream), bufio.NewWriter(stream))

    go readData(rw)
    go writeData(rw)

    // 'stream' will stay open until you close it (or the other side closes it).
}
```

3. **Find peers nearby using mdns**

New [mdns discovery](https://godoc.org/github.com/libp2p/go-libp2p/p2p/discovery#NewMdnsService) service in host.

```go
notifee := &discoveryNotifee{PeerChan: make(chan peer.AddrInfo)}
ser, err := discovery.NewMdnsService(peerhost, rendezvous, notifee)
```
register [Notifee interface](https://godoc.org/github.com/libp2p/go-libp2p/p2p/discovery#Notifee) with service so that we get notified about peer discovery

```go
	ser.Start()
```



4. **Open streams to peers found.**

Finally we open stream to the peers we found, as we find them

```go
	peer := <-peerChan // will block until we discover a peer
	// this is used to avoid call `NewStream` from both side
	if peer.ID > host.ID() {
		// if other end peer id greater than us, don't connect to it, just wait for it to connect us
		fmt.Println("Found peer:", peer, " id is greater than us, wait for it to connect to us")
		continue
	}
	fmt.Println("Found peer:", peer, ", connecting")

	if err := host.Connect(ctx, peer); err != nil {
		fmt.Println("Connection failed:", err)
		continue
	}

	// open a stream, this stream will be handled by handleStream other end
	stream, err := host.NewStream(ctx, peer.ID, protocol.ID(cfg.ProtocolID))

	if err != nil {
		fmt.Println("Stream open failed", err)
	} else {
		rw := bufio.NewReadWriter(bufio.NewReader(stream), bufio.NewWriter(stream))

		go writeData(rw)
		go readData(rw)
		fmt.Println("Connected to:", peer)
	}
```

## Authors
1. Bineesh Lazar
</file>

</files>
